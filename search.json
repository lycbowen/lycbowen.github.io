[{"title":"123d design常见问题汇总","url":"/2021/08/27/123d-design/","content":"将实体接触地面放置选中实体后输入法在英文状态下按D\n菜单中的草图和基本体&#x3D;&gt;草图的区别\n基本体&#x3D;&gt;草图可以放置在弧面上，草图不能直接绘制在弧面上\n草图可以悬空绘制，基本体&#x3D;&gt;草图不能直接悬空放置\n\n不要提前合并实体将多个实体合并为一个实体后不可撤回，尽量最后再进行合并\n不要提前删除草图尽量不要提前删除草图，可隐藏后到最后统一进行删除，若手误删除可投影单个面后生成草图。\n修改&#x3D;&gt;压、拉 和 构造&#x3D;&gt;拉伸 的区别\n菜单栏的修改&#x3D;&gt;压、拉不能使实物消失，构造&#x3D;&gt;拉伸可以反向拉伸使实物消失。\n构造&#x3D;&gt;拉伸 不可针对曲面，修改&#x3D;&gt;压、拉可对曲面进行操作。\n\n扫掠一定要选择正对着路径的那个面\n抽壳单个实体只能抽壳一次，可按住ctrl键选择多个面进行抽壳。 若需要多次对单一实体抽壳，可分割实体为多个实体后进行抽壳。\n放样多个面选择的顺序可能会影响放样的结果，需按顺序依次选择草图。放样过渡比较平缓，可能会产生畸形，可增加多个面来进行辅助操作。\n修剪和延伸修剪和延伸只可发生在单个草图的内部， 不可发生在网格上的两个并列草图之间。\n草图绘制单次绘制的多个闭合或非闭合草图属于同一个草图，选中一个即全部选中，删除则会全部删除，可选中单条路径后逐条进行删除。\n对齐和吸附善用对齐和吸附可以将两个实体进行排列操作。\n分离的用途将实体相减后可达到将单个实体分割为多个不连接的实体，但此时仍不可操作其中一部分，需进行分离操作后即可对单个实体进行移动等操作。\n","categories":["3D打印"],"tags":["123d design"]},{"title":"Python使用virtualenv环境","url":"/2021/08/21/Arch-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8virtualenv%E7%8E%AF%E5%A2%83/","content":"在win下使用venv环境通过python内置的venv模块\npython -m venv .venvcd .venv/Scriptsactivate.bat\n退出venv环境\ndeactivate.bat\nLinux下使用venv环境通过python内置的venv模块\npython -m venv .venvsource ./.venv/bin/activate\n退出venv环境\ndeactivate"},{"title":"Arch Linux安装教程","url":"/2021/03/28/Arch-Linux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","content":"设置live环境字体(可选)setfont ter-132b\n\n启动ssh服务(可选)passwdsystemctl start sshd.service\n\n网络设置\n有线连接ping www.archlinux.org\n无线连接通过 iwctl连接无线网iwctldevice liststation wlan0 scanstation wlan0 get-networksstation wlan0 connect SSIDquit\n\n磁盘分区\n利用cfdisk给磁盘分区\nlsblk -f # 查看逻辑驱动器详情cfdisk /dev/nvme0n1 # 修改磁盘分区布局fdisk -l /dev/nvme0n1 # 查看修改后的分区\n格式化相关分区\n# EFImkfs.vfat -F 32 /dev/nvme0n1p1fatlabel /dev/nvme0n1p1 EFI# SWAPmkswap -L SWAP /dev/nvme0n1p2# systemmkfs.btrfs -f -L ARCH /dev/nvme0n1p3 # 格式化mount -t btrfs /dev/nvme0n1p3 /tmpbtrfs subvolume create /tmp/@ # 挂载状态下创建子卷btrfs subvolume create /tmp/@home # 挂载状态下创建子卷btrfs subvolume create /tmp/@snapshotsbtrfs subvolume create /tmp/@var_logbtrfs subvolume create /tmp/@var_cacheumount /tmp\n\n\n也可使用默认ext4文件系统\nmkfs.ext4 -L ROOT /dev/nvme0n1p3\n\n\n挂载相关分区\nmount -o subvol=@ /dev/nvme0n1p3 /mntmkdir /mnt/homemount -o subvol=@home /dev/nvme0n1p3 /mnt/homemkdir -p /mnt/var/logmount -o subvol=@var_log /dev/nvme0n1p3 /mnt/var/logmkdir -p /mnt/var/cachemount -o subvol=@var_cache /dev/nvme0n1p3 /mnt/var/cachemkdir /mnt/bootmount /dev/nvme0n1p1 /mnt/boot\n启用swap分区\nswapon /dev/nvme0n1p2\n\n安装系统\n换源\nnvim /etc/pacman.d/mirrorlist\n\nServer = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch\n安装基础包\npacstrap -K /mnt base linux linux-firmware base-develpacstrap /mnt neovim # 文本编辑器pacstrap /mnt btrfs-progs dosfstools # 文件系统支持pacstrap /mnt networkmanager # 网络管理\n生成分区表\ngenfstab -U /mnt &gt;&gt; /mnt/etc/fstabcat /mnt/etc/fstab\n进入新系统\narch-chroot /mnt\n\n设置时区ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimehwclock --systohc\n\n\nwindows和linux时间同步，将windows时间同步为UTC，并手动禁用自动更新时间\nreg add &quot;HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\TimeZoneInformation&quot; /v RealTimeIsUniversal /d 1 /t REG_DWORD /f\n设置语言nvim /etc/locale.gen # en_US.UTF-8 UTF-8  zh_CN.UTF-8 UTF-8locale-genecho LANG=en_US.UTF-8 &gt; /etc/locale.conf\n\n设置主机名echo laptop-arch &gt;&gt; /etc/hostname\n\n设置hostsnvim /etc/hosts\n\n127.0.0.1   localhost::1     localhost127.0.1.1   laptop-arch.localdomain laptop-arch\n\n生成initramfs若需要给系统添加睡眠支持，则需要添加resume hook并重新生成 initramfs\nnvim /etc/mkinitcpio.confmkinitcpio -P\n\n设置root用户密码passwd\n\n安装引导程序安装微码\npacman -S amd-ucode efibootmgr # intel 平台则安装 intel-ucode\n\n设备开机需利用引导程序来进行加载，可选 grub2(需自行安装) 或systemd-boot(systemd自带)\npacman -S grub os-prober # os-prober 可检测已安装的win系统grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUBls -la /dev/disk/by-uuidnvim /etc/default/grub # GRUB_CMDLINE_LINUX_DEFAULT=&quot;resume=UUID=xx&quot;grub-mkconfig -o /boot/grub/grub.cfg\n\n新建用户useradd -mG wheel mnsdpasswd mnsdnvim /etc/sudoers # 赋予wheel组用户sudo权限\n\n取消挂载分区umount /mnt/home /mnt/boot /mnt/var/cache /mnt/var/log /mntreboot\n\n重新启用网络启动 NetworkManager.service\nsudo systemctl enable --now NetworkManager.service\n\n连接wi-fi\nnmtui\n\n测试网络连通\nping www.archlinux.org\n\n添加快照支持安装 snapper\nsudo pacman -S snapper\n\n创建配置文件\nsudo snapper -c root create-config /sudo snapper -c home create-config /homemkdir /.snapshotsmkdir /home/.snapshotscat &lt;&lt; EOF &gt;&gt; /etc/fstabUUID=xxx       /.snapshots     btrfs           rw,relatime,compress=zstd:3,space_cache=v2,subvolid=266,subvol=/@/.snapshots    0 0UUID=xxx       /home/.snapshots        btrfs           rw,relatime,compress=zstd:3,space_cache=v2,subvolid=264,subvol=/@home/.snapshots        0 0EOF\n\n新建快照\nsudo snapper -c root create --description &quot;install done!&quot;\n\n安装必要软件\n添加 archlinuxcn源\nsudo nvim /etc/pacman.conf # 去掉color注释，添加archlinuxcn源\n\n[archlinuxcn]Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch\n\nsudo pacman -Syy &amp;&amp; sudo pacman -S archlinuxcn-keyring\n\n\n签名密钥失败\nsudo pacman -Syu havegedsudo systemctl start havegedsudo systemctl enable havegedsudo rm -fr /etc/pacman.d/gnupgsudo pacman-key --initsudo pacman-key --populate archlinuxsudo pacman-key --populate archlinuxcn\n\n\nPGP签名错误\n这个错误表明 archlinuxcn-keyring包的PGP签名受到了信任级别的限制。在Arch Linux系统上，为了确保软件包的完整性和安全性，软件包管理器（例如Pacman）使用PGP签名进行验证。在这种情况下，签名的信任级别被认为是边缘信任（marginal trust）。\n解决方法：\n\n手动提高签名的信任级别sudo pacman-key --lsign-key farseerfc@archlinux.org\n忽略签名检查sudo pacman -Syy --noconfirm archlinuxcn-keyring\n手动导入密钥gpg --recv-keys &lt;密钥ID&gt;\n\n\n\n安装桌面环境\nsudo pacman -S gnome kittysudo systemctl enable --now gdm\n安装必要软件及驱动\nsudo pacman -S adobe-source-han-serif-otc-fonts # 思源宋体sudo pacman -S noto-fonts-emoji # emoji表情sudo pacman -S bluez bluez-utils # 蓝牙sudo pacman -S paru # AUR助手sudo pacman -S zsh # shellparu -S google-chrome-stablesudo pacman -S clash-verge-rev proxychains-ngsudo pacman -S ffmpeg vlcsudo pacman -S flameshot # 截屏sudo pacman -S obs-studio # 录屏sudo pacman -S ffmpegthumbnailer # 视频缩略图依赖sudo pacman -S fcitx5 fcitx5-chinese-addionsudo pacman -S yazi tree sudo pacman -S typora # markdownsudo pacman -S drawio-desktop-bin # 流程图\n\n备份与恢复sudo pacman -Qqen &gt; packages-repository.txt # 备份官方仓库安装的包sudo pacman -Qqem &gt; packages-AUR.txt # 备份AUR仓库安装的包sudo pacman --needed -S - &lt; packages-repository.txt cat packages-AUR.txt | xargs yay -S --needed --noconfirmsudo pacman -R `pacman -Qdtq` #删除无用包\n","categories":["Linux"],"tags":["ArchLinux","Linux安装"]},{"title":"Arduino 知识点汇总","url":"/2023/02/19/Arduino-archieve/","content":"\n\n\n函数名\n参数\n作用\n\n\n\nloop\n\n循环\n\n\nsetup\n\n初始化\n\n\npinMode\n\n\n\n\ndigitalWrite\n\n\n\n\ndelay\n\n\n\n\ntone\n\n\n\n\nSerial.print\n\n\n\n\nSerial.println\n\n\n\n\nSerial.begin\n\n\n\n\n\n\n\n\n\n\n\n\n其他生词\n含义\n\n\n\nDigital\n数字，数码\n\n\nSerial\n连续的\n\n\ntone\n音调，声调\n\n\nint\n整数\n\n\nvolatile\n易变的\n\n\n\n初识Arduino、闪烁灯安装步骤\n安装开发板子对应的usb转串口驱动\n安装Arduino IDE，老版本Mixly内置老版本Arduino IDE，但仅英文版，新版本Mixly内置Arduino cli，建议单独安装Arduino IDE 2.0.x版本\n安装自己对应的开发板的管理器，如Arduino AVR Boards by Arduino（内置源自带）\n连接电脑与开发板，选择开发板型号和端口号信息\n\n第一个demo\n必须包含且仅可包含一个setup函数(初始化函数，被执行一次)和loop函数(在初始化后被循环执行)\n\n代码规范\n\n语句规范。语句以;结尾\n命名规范\n注释规范。command + / 行注释；option + shift + a 块注释\n缩进规范。tab 增加缩进；shift+tab 减少缩进\n结构规范。 command + t 格式化程序\n\n\n控制LED灯闪烁\nvoid setup() &#123;  //初始化，只被执行一次  &#125;void loop() &#123;  // 循环，重复执行  digitalWrite(4, HIGH); // 4管脚数字输出高电平  delay(1000);  //单位毫秒  digitalWrite(4, LOW); // 4管脚数字输出低电平  delay(1000);  //单位毫秒&#125;\n\n\nsetup和loop都是程序所必须包含的部分，不可省略任何一个！\n\n\n\n程序烧录流程\n编译。通过特定的c、c++编译器（avr-gcc、avr-g++）等编译工具链接相关库进行编译，语法错误则终止编译过程\n上传到开发板。通过usb转串口芯片将编译好的二进制文件通过usb数据线传输到开发板，端口选择错误或数据线故障或开发板故障会中断上传\n运行。开发板执行setup函数以及loop函数\n\n\n代码规范、流水灯官方文档Arduino 官网\n官网参考说明\n流水灯分别将三个LED灯泡连接至4、5、6号管脚，依次使管脚输出高电平、低电平，并进行相应的延时。\n\ndelay 函数接收参数的单位默认为毫秒\n高电平可以用 HIGH、1、true 代替，低电平可以用 LOW、0、false 代替，注意大小写！不可忽略！\n\nvoid setup() &#123;  //初始化，只被执行一次  &#125;void loop() &#123;  // 循环，重复执行  digitalWrite(4, HIGH); // 4管脚数字输出高电平  delay(1000);  //单位毫秒  digitalWrite(4, LOW); // 4管脚数字输出低电平  digitalWrite(5, 1); // 5管脚数字输出高电平  delay(1000);  //单位毫秒  digitalWrite(5, 0); // 5管脚数字输出低电平  digitalWrite(6, true); // 6管脚数字输出高电平  delay(1000);  //单位毫秒  digitalWrite(6, false); // 6管脚数字输出低电平&#125;\n\n\n\n蜂鸣器蜂鸣器分为有源蜂鸣器和无源蜂鸣器两种，有源蜂鸣器通电可直接发声音，无源蜂鸣器只在接通或断开电源时发声，所以需要通过高低电平的切换来进行驱动。\nvoid setup() &#123;  //初始化，只被执行一次  &#125;void loop() &#123;  // 循环，重复执行  digitalWrite(4, HIGH); // 有源蜂鸣器，接入高电平直接发声    digitalWrite(5, HIGH); // 无源蜂鸣器，接入高电平只短暂响一下后停止发生&#125;\n\n无源蜂鸣器需要通过高低电平的切换来进行发声\nvoid setup() &#123;  //初始化，只被执行一次  &#125;void loop() &#123;  // 循环，重复执行  digitalWrite(5, HIGH); // 无源蜂鸣器  delay(300);  digitalWrite(5, LOW);  delay(300);&#125;\n\n\n\ntone函数对该方式进行了封装，可直接使用tone函数来进行驱动蜂鸣器\nvoid setup() &#123;  //初始化，只被执行一次  &#125;void loop() &#123;  // 循环，重复执行  tone(9,300); // 管脚：9 频率：300 时长：永远    tone(9,300,2000); // 管脚：9 频率：300 时长：2s    noTone(9); // 停止发声&#125;\n\n\n\n\n\nC（do）：261.63 Hz\nD（re）：293.66 Hz\nE（mi）：329.63 Hz\nF（fa）：349.23 Hz\nG（so）：392.00 Hz\nA（la）：440.00 Hz\n\n\n串口打印通过调用Serial.print函数或者Serial.println函数从开发板向外围设备（如电脑）发送文本信息。\n使用串口前需要先初始化设置串口的波特率，即传输速率，通常设置为9600、19200、57600、115200等，没有特殊需求尽量不要设置过高。\nvoid setup() &#123;  //初始化，只被执行一次  Serial.begin(9600); //设置串口波特率&#125;void loop() &#123;  // 循环，重复执行  // Serial.print(10); // 串口打印不换行  Serial.println(10); // 串口打印换行&#125;\n\n\n\n当开发板通过usb数据线连接至电脑时，通过电脑端的川口监视器即可看到接收到的数据。\n数字输入、分支结构数字输入通过digitalRead读取数字输入信号，并通过串口打印将其发送至电脑\nvoid setup() &#123;  &#125;void loop() &#123;  int v; // 定义一个整数变量  v = digitalRead(4); // 将数字管脚4读取到的值赋值给变量v，等号读作赋值号&#125;\n\n通过按键控制LED灯亮灭分支结构\nif (条件1) &#123;  语句1;&#125;if (条件2) &#123;  语句2;&#125; else &#123;  语句3;&#125;\n\n\n条件不可省略！条件必须加括号；条件满足，则执行其后紧邻的一个大括号内的所有语句\n\n比较运算符\n\n\n\n比较运算符\n含义\n\n\n\n&gt;\n大于\n\n\n&lt;\n小于\n\n\n&gt;&#x3D;\n大于或等于\n\n\n&lt;&#x3D;\n小于或等于\n\n\n!&#x3D;\n不等于\n\n\n&#x3D;&#x3D;\n等于\n\n\n按下则亮，松开则灭\n\n\n初始状态为灭，按1下则亮，再按一下则灭\n\n\n局部变量与全局变量\n局部变量\n声明在函数内部，只在当前函数的内部生效。\n\n全局变量\n声明在所有函数的外部，在所有函数内都可以读取到该值。\n\nvolatile关键字的作用是告诉编译器，在对变量进行读写操作时，不要对变量进行任何优化，以确保变量的值能够正确地被读取和更新。在多线程和中断情况下，如果不使用volatile关键字，编译器可能会对变量进行一些优化，从而导致变量的值与预期不符。\n\n\n\n"},{"title":"Bilibili常用api记录","url":"/2021/03/20/Bilibili%E5%B8%B8%E7%94%A8api%E8%AE%B0%E5%BD%95/","content":"应援团消息详情团消息接口\nget请求参数(需要sessdata)\n\n\n\n请求参数\n值\n备注\n\n\n\ntalker_id\n团号\n必选\n\n\nsession_type\n（未知）\t2\n\n\n\nsize\n页容量\n可能是7000+，不确定，待验证\n\n\nbegin_seqno\n开始偏移量\n可选，默认为最新size条数的偏移量\n\n\n扫码登录请求扫码请求接口\nget请求，无需参数\n扫码登录确认扫码确认接口\npost请求参数\n\n\n\n请求参数\n值\n备注\n\n\n\noauthKey\n扫码登录秘钥\n必选，通过上一步get请求获取\n\n\n查看用户信息查看用户信息接口\nget请求参数\n\n\n\n请求参数\n值\n备注\n\n\n\nmid\n目标用户uid\n必要\n\n\n查看用户所有投稿获取用户所有投稿\nget请求参数\n\n\n\n请求参数\n值\n备注\n\n\n\nmid\n用户uid\n必选\n\n\nps\n页容量\n必选\n\n\npn\n页码\n必选\n\n\n查看视频信息查看视频信息接口\nget请求参数\n\n\n\n请求参数\n值\n备注\n\n\n\naid\n视频avid\n2选1\n\n\nbvid\n视频bvid\n2选1\n\n\n查看评论区明细评论区接口\nget请求参数\n\n\n\n请求参数\n值\n备注\n\n\n\ntype\n评论区类型代码\n必选，视频投稿为1\n\n\noid\n目标评论区ID\n必选，视频投稿时为稿件avID值\n\n\nmode\n排序方式\n0热度，1热度+时间，2时间\n\n\nnext\n评论页选择\n默认0，热度为正序，时间\n\n\nps\n页容量\n默认20\n\n\n","categories":["bilibili"],"tags":["bilibili","爬虫"]},{"title":"EV3常见问题汇总","url":"/2021/08/27/EV3%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","content":"程序直接结束，部分模块一闪而过显示模块和播放声音文件等模块不会阻止程序的继续运行，若需持续显示或播放则需要加等待模块或重复执行模块。\n条件循环模块当满足条件时跳出循环模块，不满足时一直循环。\n电机指定条件运行当电机开启指定圈数、秒数、度数进行运行时会阻止后面程序的执行，若外部嵌套条件循环则只会在结束时进行判断是否跳出循环。\n定义变量当程序内仅定义了单个变量时可以不命名，当定义了多个变量时必须进行命名。\n传感器或马达不起作用的常见原因连线过松，没有插紧；端口选择不正确。\n","categories":["EV3"],"tags":["EV3"]},{"title":"FTP server部署防踩坑","url":"/2021/11/17/FTP-server/","content":"在安卓等设备上使用rsync、scp等工具时始终不方便，此时ftp就显得方便好用，但FTP server端的坑接连不断。\n\n安装sudo apt-get install vsftpd # debian系sudo pacman -S vsftpd # arch系\n\n配置新版本默认配置文件位置为/etc/vsftpd.conf\n# 禁止匿名用户登陆anonymous_enable=NO# 设置家目录local_enable=YESlocal_root=/PATH/TO/FTPHOME# 家目录可写write_enable=YES# 禁止离开家目录，家目录的父目录必须不可写# chroot_list_file指定白名单，且必须存在chroot_local_user=YESchroot_list_enable=YESchroot_list_file=/etc/vsftpd.chroot_list# 指定可登陆用户，userlist_file保存白名单userlist_enable=YESuserlist_deny=NOuserlist_file=/etc/vsftpd.user_list# 指定监听和传输端口，被动模式listen_port=9090pasv_enable=YESpasv_min_port=5000pasv_max_port=5003\n\n\n\n启动服务sudo systemctl start vsftpd.service\n\n常见问题账户密码正确，配置无问题，但是无法登陆\n#若登陆用户shell非`/etc/shells`下的shell,则需修改`/etc/pam.d/vsftpd`文件，将该行注释掉#auth   required        pam_shells.so\n\n服务器发回了不可路由的地址。使用服务器地址代替的问题\n# 需同时设置listen=YESlisten_ipv6=NO"},{"title":"JupyterNotebook 使用方法","url":"/2021/09/04/JupyterNotebook-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","content":"JupyterNotebook简介JupyterNotebook可以保留每次Python程序的输出结果以及错误信息，方便后期整理汇总。并可兼容markdown语法，方便记录笔记。\nJupyterNotebook安装步骤首先需确保电脑安装有Python环境，通过安装jupyter模块即可。通过venv环境安装jupyter则可保证系统环境不被破坏，且方便管理与卸载。\n新建venv环境python -m venv .venv\n进入venv环境.\\.venv\\Scripts\\activate\n升级pip版本python -m pip install --upgrade pip\n安装Jupyterpip install jupyter\n\n若安装速度太慢或报错，可使用其它镜像源安装\npip install jupyter -i https://pypi.tuna.tsinghua.edu.cn/simple/\n运行Jupyter Notebookjupyter notebook\n设置密码jupyter notebook password\n若界面显示为英语，可按ctrl + c 终止程序后设置环境变量set LANG=zh_CN.UTF-8\n\nJupyterNotebook支持的Markdown常用语法# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题[百度](https://www.baidu.com)&gt; 高亮\n","categories":["Python"],"tags":["Python"]},{"title":"知识点到课程对应表","url":"/2023/02/23/KnowledgePointToCourse/","content":"动力机械\n\n\n机械结构与物理原理\n课程\n\n\n\n齿轮水平传动\n小车、陀螺发射器、风扇\n\n\n齿轮垂直传动\n四驱车、飞椅\n\n\n齿轮加减速、齿轮二级加减速\n陀螺发射器、风扇\n\n\n皮带传动\n智能垃圾桶、起重机、舂米机、护城河（开合桥）\n\n\n皮带交叉传动\n扫地机器人\n\n\n履带传动\n坦克\n\n\n三角形的稳定性\n各种支架\n\n\n四边形的不稳定性\n伸缩钳\n\n\n杠杆\n天平、投石车、跷跷板\n\n\n定滑轮、动滑轮、滑轮组\n钓鱼竿、起重机、升旗杆\n\n\n重力势能\n重力小车\n\n\n弹性势能\n皮筋小车、纸飞机发射器\n\n\n摩擦力\n赛龙舟、青蛙\n\n\n惯性\n飞轮车\n\n\n曲柄摇杆\n稻草人、雨刷器、手摇风扇\n\n\n曲柄滑块\n缝纫机、牙刷、足球守门员\n\n\n凸轮\n石油开采机、舂米机\n\n\n棘轮棘爪\n捕鼠器、机械尺蠖\n\n\n蜗轮蜗杆\n开合桥、摩天轮\n\n\nwedo 传感器与程序模块\n\n\n传感器\n课程\n\n\n\n运动传感器\n跟随小车、避障小车\n\n\n倾斜传感器\n飞机、遥控风扇、护城河（开合桥）\n\n\n变量\n快递计数器\n\n\n随机数\n足球守门员\n\n\nspike 传感器\n\n\n传感器\n课程\n\n\n\n距离传感器\n智能避障小车\n\n\n颜色传感器\n颜色分拣机\n\n\n压力传感器\n碰碰车、电子秤\n\n\n陀螺仪\n平衡车\n\n\n开源电子硬件\n\n\n模块\n课程\n\n\n\n红外接收器、红外遥控器\n遥控车\n\n\n超声波距离传感器\n避障小车\n\n\n温湿度传感器\n智能灌溉、加湿器\n\n\n光照传感器\n声控灯\n\n\n声音传感器\n声控灯\n\n\n舵机\n摇头风扇\n\n\n陀螺仪\n平衡车\n\n\n蜂鸣器\n电子闹钟、音乐盒\n\n\n"},{"title":"解决linux下新版pycharm等不能输入中文问题","url":"/2021/02/28/LinuxPycharm/","content":"Linux下使用pycharm，idea等出现不能输入中文pycharm中使用中文不能正常输入，输入三个字母后强制切回英文输入法，只能通过外部复制粘贴或放弃输入中文，直接用英文注释。\n测试环境：Archlinux + ibus\n解决方法：\n\n下载JBR\n打开pycharm设置，插件搜索安装runtime插件\n重启pycharm，双击shift输入runtime，选中手动下载的JBR即可\n\n","categories":["Linux"],"tags":["Python","Pycharm","Linux"]},{"title":"安卓双系统的分析与实现","url":"/2021/02/25/MobileMultirom/","content":"注:本文为资深刷机用户推荐，小白请勿轻易尝试，可作为分析思路浏览，以下操作如未说明则都需解锁Bootloader锁(如果有的话)，并已获得root权限。\n引言首先你应对电脑多系统有大致了解，BIOS如何引导操作系统，Bootloader是干了什么事，怎样通过磁盘分区、多重引导等实现多系统。相对于手机这些嵌入式系统，由于牵涉到各家硬件驱动是否开源等等一些问题，通过类似电脑端grub，systemd-boot，refind等达到多重引导是较难实现的。但是通过转换思路，既然操作系统它是通过挂载对应磁盘分区进行之后的一系列操作，是否又可以通过改变分区表(或者说特定分区指向)从而达到敌不动我动的效果，从而欺骗了bootloader。\n安卓双系统底层实现原理磁盘分区工具的选择方向既然已经清楚了，那接下来就是具体思路。由于安卓系统本就基于linux内核，通过一些C&#x2F;C++库支撑，每个apk应用都是运行在ART(Dalvik)虚拟机之上。则可以尝试通过一些磁盘分区工具尝试对分区进行删改，在arm架构处理器上处理gpt分区表用的较多的GNU工具有sgdisk、parted等，可自行选择。由于大多数手机系统都已经内置sgdisk工具，本文以sgdisk举例，如系统未内置则需要自行解决，解决方法参考linux。\n安卓手机磁盘分区在对磁盘进行重分区之前，有必要先对手机内存(如未说明则后文内存指手机内部存储，即等价于电脑硬盘，非电脑内存条)驱动器有一定了解，目前市面上手机内存主要为ufs闪存，有少部分为emmc闪存，在磁盘分区处理上有稍微差异，本文主要以ufs闪存为例。ufs闪存的手机通常把逻辑驱动器划分为sda,sdb,sdc,sdd,sde,sdf等，设备分别映射文件到&#x2F;dev&#x2F;block&#x2F;sda,&#x2F;dev&#x2F;block&#x2F;sdb…等，emmc则映射到&#x2F;dev&#x2F;block&#x2F;mmcblk0…，磁盘分区表记录了该逻辑驱动器上的各分区始末位置、分区大小等信息，位于该逻辑驱动器的前n个块。\nmix2s分区表信息如下：\n$ sgdisk --print /dev/block/sdaDisk /dev/block/sda: 14419968 sectors, 55.0 GiBLogical sector size: 4096 bytesDisk identifier (GUID): E9F67F91-775B-75A5-2D93-3CDF9DEB39EFPartition table holds up to 32 entriesFirst usable sector is 6, last usable sector is 14419962Partitions will be aligned on 2-sector boundariesTotal free space is 0 sectors (0 bytes)Number  Start (sector)    End (sector)  Size       Code  Name   1               6               9   16.0 KiB    FFFF  switch   2              10              17   32.0 KiB    FFFF  ssd......         ......         ......  18           98304          311295   832.0 MiB   FFFF  cust  19          311296          327679   64.0 MiB    FFFF  recovery  20          327680          393215   256.0 MiB   FFFF  cache  21          393216        14419962   53.5 GiB    FFFF  userdata  $ sgdisk --print /dev/block/sdeDisk /dev/block/sde: 1179648 sectors, 4.5 GiBLogical sector size: 4096 bytesDisk identifier (GUID): 09A16BAE-F899-2669-BA14-602F3A220D2FPartition table holds up to 64 entriesFirst usable sector is 6, last usable sector is 1179642Partitions will be aligned on 2-sector boundariesTotal free space is 16379 sectors (64.0 MiB)Number  Start (sector)    End (sector)  Size       Code  Name   1               6              13   32.0 KiB    FFFF  sec   2              14              21   32.0 KiB    FFFF  limits......         ......         ......  42           24576           32767   32.0 MiB    FFFF  splash  43           32768           40959   32.0 MiB    FFFF  logo  44           40960           49151   32.0 MiB    FFFF  dsp  45           49152           65535   64.0 MiB    FFFF  boot  46           65536          114687   192.0 MiB   0700  modem  47          114688          376831   1024.0 MiB  FFFF  vendor  48          376832         1163263   3.0 GiB     FFFF  system  49         1163264         1179642   64.0 MiB    FFFF  last_parti\nsgdisk使用方法sgdisk工具需要在su下使用，详细使用方法可在终端输入sgdisk按回车查看以下列出几个需要用到的几个命令\n$ sgdisk --print /dev/block/sda #打印驱动器sda分区表$ sgdisk --new=26:12345:34567 #新建分区号为26的分区，从第12345块开始，到34567块结束$ sgdisk --new=27:0:+512M /dev/block/sda #新建分区号为27的分区，从第一个可以容下512M的空间的起始位置开始，建立一个512M的分区$ sgdisk --new=0:0:0 /dev/block/sda #从第一个可用分区号开始，从第一个可用分区块位置开始，到结束$ sgdisk --change-name=18:boot /dev/block/sda #将分区号为18的分区改名为boot$ sgdisk --delete=21 /dev/block/sda #删除分区号为21的分区\n注:以上命令均需指定驱动器位置，不指定则命令无任何作用。电脑上驱动器一般为&#x2F;dev&#x2F;sda，手机上稍微有不同之处，通常为&#x2F;dev&#x2F;block&#x2F;sda，且执行命令后重启生效，所以在未完成全部操作之前切勿重启手机，重启即黑砖，需9008复活。后悔药：在结束之前可随时刷入最初备份的原分区表进行回退\n双系统共存方法结构概览\n\n双分区的选择接下来，要通过对不同系统差异的分区进行重分区，做双分区处理，相同的当然就没必要了。\n\n\n\n分区名\n作用\n所在驱动器（基于mix2s示范）\n\n\n\nsystem\n系统分区\nsde\n\n\nvendor\n驱动分区\nsde\n\n\nboot\n内核分区\nsde\n\n\nuserdata\n用户数据分区\nsda\n\n\ndsp\n可能和媒体声音有关\nsde\n\n\nmodem\n基带解调器\nsde\n\n\n由于开机时bootloader加载时挂载分区是根据分区名称进行挂载，只认名字，所以要实现双系统，就需要将这些分区可以进行单独分开(自由选择分开哪些分区，此处只做示范)，分为system1，system2，vendor1，vendor2，boot1，boot2，userdata1，userdata2，dsp1，dsp2，modem1，modem2，再进一步做屏蔽处理。\n分区表的备份可以用sgdisk等工具自带的备份命令直接备份，也可直接用dd命令拷贝出驱动器前512个块（已完整包含该驱动器所有分区表信息）\n$ dd if=/dev/block/sda of=/sdcard/sda_fqb bs=512 count=1024 #从起始位置开始拷贝sda驱动器上的块，每次512B，累计1024次，即512K\n系统一分区的实例实现双系统的切换，则我们需要两张分区表，一张保存系统一的磁盘分区情况如下，此时系统二对应分区被屏蔽掉，开机不加载\n\n\n\n系统一\n系统二（不加载）\n\n\n\nsystem(sde)\nsystem2(sda)\n\n\nvendor(sde)\nvendor2(sda)\n\n\nboot(sde)\nboot2(sda)\n\n\nuserdata(sda)\nuserdata2(sda)\n\n\n代码如下：（基于miMIX2s的示范）\n$ dd if=/dev/block/sda bs=512 count=1024 of=/sdcard/sda #备份单系统时的分区表，后悔药$ dd if=/dev/block/sde bs=512 count=1024 of=/sdcard/sde$ sgdisk --delete=21 /dev/block/sda #删掉原data，留下空闲空间$ sgdisk --new=21:0:+64M /dev/block/sda --change-name=21:boot2 /dev/block/sda #新建另一个系统相关分区$ sgdisk --new=22:0:+1024M /dev/block/sda --change-name=22:vendor2 /dev/block/sda$ sgdisk --new=23:0:+3584M /dev/block/sda --change-name=23:system2 /dev/block/sda$ sgdisk --new=24:0:+5632M /dev/block/sda --change-name=24:userdata2 /dev/block/sda$ sgdisk --new=25:0:+40000M /dev/block/sda --change-name=25:userdata /dev/block/sda #将剩余空间还非配给这个系统$ dd if=/dev/block/sda bs=512 count=1024 of=/sdcard/sda_fqb1$ dd if=/dev/block/sde bs=512 count=1024 of=/sdcard/sde_fqb1\n系统二分区的实例另一张保存系统二的磁盘分区情况如下，此时系统一对应分区被屏蔽掉，开机不加载\n\n\n\n系统一（不加载）\n系统二\n\n\n\nsystem1\nsystem\n\n\nvendor1\nvendor\n\n\nboot1\nboot\n\n\nuserdata1\nuserdata\n\n\n代码如下：（基于miMIX2s的示范）\n\n\n\n$ sgdisk --change-name=25:userdata1 /dev/block/sda$ sgdisk --change-name=21:boot /dev/block/sda$ sgdisk --change-name=22:vendor /dev/block/sda$ sgdisk --change-name=23:system /dev/block/sda$ sgdisk --change-name=24:userdata /dev/block/sda$ sgdisk --change-name=45:boot1 /dev/block/sde$ sgdisk --change-name=47:vendor1 /dev/block/sde$ sgdisk --change-name=48:system1 /dev/block/sde$ dd if=/dev/block/sda bs=512 count=1024 of=/sdcard/sda_fqb2$ dd if=/dev/block/sde bs=512 count=1024 of=/sdcard/sde_fqb2\n双系统的切换每次只要载入不同的分区表信息，就能实现系统的切换，注意一定要保管好分区表信息不可丢失\n$ dd if=/sdcard/sda_fqb1 of=/dev/block/sda bs=512 count=1024 #将系统一sda分区表信息载入$ dd if=/sdcard/sde_fqb1 of=/dev/block/sde bs=512 count=1024 #将系统一sde分区表信息载入\n载入相关驱动器分区表信息即可切换到系统一。系统二同理\n双系统方案的优化将更多的分区独立开来当多个系统之间安卓底层版本不同时极易出现各种bug，即部分分区被共用所产生的问题，例如modem导致基带问题、dsp导致媒体声音问题。解决方案为将更多的分区给分开，当熟练掌握原理后即可仿照上例实现，但部分核心分区不可随意动手，切勿贪心。\n切换方式多样化将分区表或打包有分区表的卡刷包放至例如cust等空闲分区，通过如下方式切换\n\n终端命令切换。即上方提到的方式\nshell脚本切换。将命令打包添加至shell脚本，每次执行脚本即可\n卡刷包切换。将分区表打包进卡刷包到rec卡刷\nrecovery切换。将打包好的卡刷包打包进recovery.img，需自行搜索解包工具\napp切换。\n\n分区共享数据将未挂载的另外一个系统的相应分区挂载到本系统。\n$ mkdir /mnt/data_2$ mount -t ext4 -o rw /dev/block/by-name/userdata2 /mnt/data_2","categories":["安卓刷机教程"],"tags":["安卓","双系统","刷机"]},{"title":"polybar跑马灯实时推送up最新动态","url":"/2021/03/02/PolybarPush/","content":"原理分析polybar可支持自定义module添加script并展示print返回值，利用python脚本轮番获取B站up的最新动态，检测到最新动态对应的时间戳发生改变则判定为更新动态，print最新动态内容。但原生polybar的自定义模块不支持跑马灯效果，仅可展示静态内容，但可以，利用模块的刷新间隔每次切割定长字符串来达到跑马灯的效果。\n环境要求polybar（通常搭配WM使用），python（pip）\n具体实现B站web端动态更新利用ajax技术，ajax 即 Asynchronous JavaScript and XML（异步的 JavaScript 和 XML），ajax 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。\n通过分析可得到B站历史动态api接口为：https://api.vc.bilibili.com/dynamic_svr&#x2F;v1&#x2F;dynamic_svr&#x2F;space_history\n请求方式：get\n请求参数：\n\n\n\n请求参数\n备注\n值\n\n\n\nhost_uid\n获取对应up的uid\n必选\n\n\noffset_dynamic_id\n每页偏移量\n默认为0\n\n\nvisitor_uid\n访问的uid\n可选\n\n\nplatform\n访问的平台\n可选\n\n\n安装json，requests模块\npip install jsonpip install requests\n\n通过requests模块发送get请求获得网页内容，通过json模块将字符串信息转化为字典数据进行处理。\nString &#x3D;&#x3D;&gt; Dict json.loads()\nDict &#x3D;&#x3D;&gt; String json.dumps()\n将请求到的长文本保存至文本文件，每次读取show &#x3D; [n:n+m]一共m个字符串，则还需另外引入计数器n，当长度show.len()小于一最小值时，计数器归零，polybar每次刷新返回show的值。\n","categories":["Linux"],"tags":["bilibili","polybar","bspwm"]},{"title":"Python easygui模块","url":"/2021/10/05/Python-easygui/","content":"python easygui模块的使用\n复习回顾\n列表的遍历\n字典的查询\nurllib模块的使用\njson模块的使用\n\n\n本节新知\neasygui之msgbox返回值为按钮内容\n\neg.msgbox(msg=&quot;消息内容&quot;,title=&quot;标题&quot;,ok_button=&quot;按钮名字&quot;)\n\n\neasygui之choiceboxchoicebox的选项必须是多个，返回值为按钮内容\n\neg.choicebox(msg=&quot;消息内容&quot;,title=&quot;标题&quot;,choices=(&quot;选项一&quot;,&quot;选项二&quot;))\n\n\neasygui之ccbox和boolbox和ynbox返回值为布尔值，即真或假\n\nimport easygui as egeg.ccbox(&quot;msg_content&quot;, &quot;title&quot;)eg.boolbox(&quot;msg_content&quot;, &quot;title&quot;, (&quot;1&quot;, &quot;2&quot;))\n\n\neasygui之indexboxindexbox的选项可以有多个，并且返回值为该选项对应的索引\n\nimport easygui as egeg.indexbox(&quot;msg&quot;, &quot;title&quot;, (&quot;first&quot;, &quot;second&quot;, &quot;third&quot;, &quot;forth&quot;))\n\n\neasygui之buttonboxbuttonbox的按钮可以为多个,返回值为按钮的名字\n\neg.buttonbox(msg=&quot;消息内容&quot;,title=&quot;标题&quot;,choices=(&quot;选项一&quot;,&quot;选项二&quot;))\n\n\neasygui之enterbox普通输入框,可添加初始值,返回值为输入的文本信息\n\nprint(eg.enterbox(msg=&quot;消息内容&quot;,title=&quot;标题&quot;)\n\n\neasygui之textbox文本输入框,适合输入大段文字,返回值为输入的文本信息\neasygui之integerbox数字输入框,默认可输入范围为0-99,返回值为输入数字\n\nimport easygui as egeg.integerbox(&quot;msg_content&quot;, &quot;title&quot;, lowerbound=1, upperbound=200)\n\n\neaygui之multenterbox多输入框\n\nimport easygui as egeg.integerbox(&quot;msg_content&quot;, &quot;title&quot;, (&quot;name&quot;, &quot;age&quot;, &quot;height&quot;, &quot;weight&quot;))\n\n\neasygui之passwordbox\n\nprint(eg.passwordbox(msg=&quot;请输入您的密码&quot;))\n\n\neasygui之multpasswordbox\n\nimport easygui as egeg.multpasswordbox\n\n\neasygui之egdemo通过easygui中的egdemo函数可以调用easygui模块自带的demo，可查看包含的所有功能\n\nimport easygui as egeg.egdemo()\n\n\n保存文件选择路径显示图片\n\n课后作业使用easygui设计一个图书馆后台登录及管理系统\n","categories":["Python"],"tags":["Python","easygui"]},{"title":"Python函数进阶","url":"/2021/11/25/Python-func2/","content":"Python 函数Python函数进阶课前回顾\n函数的返回值\n通过return来使主函数和外部函数形成闭环，return只能用于函数内部使用且return后的程序不会被执行\n\n变量的作用域\n变量分为局部变量和全局变量\n\n变量的命名规则\n可以由数字、字母、下划线组成，且不能以数字开头，不能包括特殊符号；可以为汉字、韩语、日语，但是尽量不要\n\n\n本节新知\n新词速记\n\nglobal 全局\n\n\n变量的作用域\n变量分为局部变量和全局变量，在函数外部定义的变量为全局变量，在函数内部定义的变量为局部变量。函数内部可以读取全局变量的值，但是不可以修改不可变的全局变量的值。\na = 1 # 整型不可变def _():    # a = a + 1 ，当取消注释后报错，函数内部不能修改不可变全局变量的值    print(a) # 函数内部可以访问全局变量_()\n\nglobal关键字\n在函数内部使用，声明该函数内使用的该变量是全局变量，则可以修改该值\na = 1 # 整型不可变def _():    global a # 声明此处的a是使用的全局变量的值    a = a + 1 # 函数可以修改该全局变量    print(a)_()\n\n数据类型的强制转换\n偷懒机制，只会进行一次转换\nint(&quot;12&quot;) # 12float(&quot;12&quot;) # 12.0float(&quot;12.3&quot;) # 12.3int(&quot;12.3&quot;) # 报错，懒惰，不能一下转两次int(float(&quot;12.3&quot;)) # 12bool(&quot;张三&quot;) # True，通常与if结合使用，但是if后表达式默认被强制转化布尔值，因此bool函数不常用\n\n函数的默认参数\n通常函数声明了几个形参，则我们调用的时候就要传递几个实参，但是有默认参数时除外，有默认参数的形参可以不传递实参。有默认参数的形参必须靠后排列。\ndef self_introduce(name, age, height=1.70, weight=75): # 两个带默参的靠后排    print(&quot;My name is &quot;+name)    print(&quot;My age is &quot;+age)    print(&quot;My height is &quot;+height)    print(&quot;My weight is &quot;+weight)    self_introduce(&quot;张三&quot;, 16) # 此时身高默认1.70，体重默认75self_introduce(&quot;李四&quot;, 17, 1.68) # 此时李四神身高1.68，体重默认75self_introduce(&quot;王五&quot;) # 报错，缺少一个必要参数self_introduce(&quot;赵六&quot;, 15, weight=60) # 此时身高默认1.70，体重指定传参60\n\nturtle与循环的综合应用\nimport turtle as t# 初始化t.speed(0)t.hideturtle()t.delay(0)color_l = [&quot;red&quot;, &quot;yellow&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;pink&quot;]size_l = []for i in range(160,39,-30):    size_l.append(i)# 画圆for i in range(len(color_l) if len(color_l)&lt;len(size_l) else len(size_l)):    t.pu()    t.goto(0,-1*size_l[i])    t.pd()    t.color(color_l[i])    t.begin_fill()    t.circle(size_l[i])    t.end_fill()t.done()\n\n课后作业复习前面所学的turtle模块的常用函数以及常见单词的拼写\n"},{"title":"Python 函数的定义与调用","url":"/2021/10/24/Python-function/","content":"Python 函数定义与函数调用\n复习回顾\nrequests模块的使用\n如何导包时起别名\n变量的命名规则\n\n\n本节新知\n什么是函数\n函数就是为了实现特定功能的代码块，其独立出来，在需要使用时直接调用，使代码变得美观，也增加了代码的复用率\ndef my_first():    print(&quot;这是我的第一个函数！&quot;)\n\n函数如何去调用\n函数调用时后面必须加括号，后面有括号的一定是一个函数，在调用时直接用“func_name()”就可以调用\ndef get_name():    print(&quot;My name is Zhang San.&quot;)get_name()\n\nPython程序的入口\ndef my_first():    print(&quot;这是我的第一个函数！&quot;)    print(&quot;begin...&quot;)if __name__==&quot;__main__&quot;:    my_first()\n\n该程序入口仅为一种规范，大家约定俗成的入口，并不是程序一定会从这里开始\n\n有参函数\n函数调用时传递的参数必须与函数定义中的参数相匹配，若未指定实参对应的形参，则按顺序进行传递\ndef my_func(a, b):    num = a / b    print(num)    if __name__==&quot;__main__&quot;:    my_func(2, 4)    my_func(4, 2)    my_func(b=2, a=4)\n\n函数的返回值\n函数通常都会有返回值，若无返回值，则返回None，函数通过return返回结果，且return后的语句都不会被执行\ndef my_add(a, b):    sum = a + b    return sum\tprint(&quot;这行代码并不会被执行...&quot;)if __name__==&quot;__main__&quot;:    my_add(2, 4)\n\n\n课后作业复习回顾以前学过的常见的函数有哪些？\n"},{"title":"Python函数进阶与高阶函数","url":"/2021/11/13/Python-func%E8%BF%9B%E9%98%B6/","content":"Python 函数Python函数进阶与高阶函数复习回顾\n如何定义一个多参函数\n\n多参函数如何进行调用\n\n函数的返回值\n\n变量的作用域\n\n\n本节新知\n常见的内置函数\n\n求绝对值函数\na = &#x27;-4&#x27;abs(a)\n\n求布尔值函数\nbool(&quot;abc&quot;)name = input(&quot;请输入你的年龄：&quot;)\n\n数据类型强制转换\nint(input(&quot;请输入你的分数：&quot;))float(&quot;12.3&quot;)int(&quot;12.3&quot;) # 报错int(float(&quot;12.3&quot;))\n\n\n变量的作用域\na = 1 # 全局变量def _(): # 函数名命名规则：字母、数字、下划线组成，且不能以数字开头    #a+=1    print(a)    _()\n\n\n\n函数嵌套\ndef outer():    print(&quot;这是外部函数&quot;)    def inner():        print(&quot;这是内部函数&quot;)    return inner()outer()\n\n默认参数\ndef func(name, age=18): # 带默认参数的形参必须靠后放置    print(&quot;我叫&quot;+name)    print(&quot;我今年&quot;+age)func(&quot;zhangsan&quot;)\n\n函数参数的数据类型\ndef add_num(a:int, b:int): # 约定俗成，非强制要求    return a+badd_num(&quot;a&quot;, &quot;b&quot;)\n\n综合练习\nanimal_list = [&quot;dog&quot;, &quot;cat&quot;, &quot;mouse&quot;, &quot;pig&quot;]def get_animal(animal: list):    print(&quot;This func only receive a list!&quot;)    animal_dict = &#123;&#125;    def change_dict(lenth=len(animal)):        for i in range(lenth):            animal_dict[animal_list[i]] = &quot;animal&quot;        return animal_dict    return change_dict()if __name__==&quot;__main__&quot;:    print(get_animal(animal_list))\n\n课后作业定义一个函数，接收两个列表，一个列表定义多种颜色，另一个列表定义多个整数作为圆的半径，调用该函数时可直接画出五个颜色不同半径不同的同心圆\n拓展：可将同心圆填充颜色变成靶子\n"},{"title":"Python requests和easygui模块的结合","url":"/2021/10/16/Python-requests-and-easygui/","content":"Python requests和easygui模块的综合应用\n复习回顾\nurllib模块的使用\njson数据与dict的转换\neasygui模块的常用函数\n\n\n本节新知\nrequests模块的安装\n\npip install requests\n\n\nrequests模块的使用requests模块是对urllib模块的二次封装，使用更加方便\n\nimport requestsurl1 = &quot;http://www.baidu.com&quot;req = requests.get(url1)req.encoding = &quot;utf-8&quot;print(req.text)\n\n\nrequests模块与urllib模块的区别requests模块通过构建的req请求的text属性来查看网页内容，urllib模块通过调用构建的req请求的read()函数来返回网页内容\n\nimport urllib.requestimport requestsurl = &quot;https://www.baidu.com&quot;req1 = urllib.request.urlopen(url)html_content1 = req1.read().decode(&quot;utf8&quot;)req2 = requests.get(url)html_content2 = req2.text\n\n\n使用easygui模块进行显示与提取数据\n\nimport easygui as egcity = eg.choicebox(&quot;请选择要查询城市的疫情数据：&quot;, &quot;疫情查询系统&quot;, [&quot;河南，郑州&quot;], [黑龙江, 哈尔滨])for city_detail in citylist:    if city = city_detail[&quot;city&quot;]:       eg.msgbox(str(city_detail), &quot;疫情查询系统&quot;)\n\n\n课后作业用requests模块和easygui模块完善疫情数据查询程序\n"},{"title":"python turtle模块的“write”与“color”","url":"/2021/10/24/Python-turtle-write/","content":"python turtle模块的“write”与“color”\n复习回顾\n导包时进行重命名\nturtle包中常用函数的简写\nturtle填充颜色的步骤\n\n\n本节新知\nturtle中几种“color”的区别\ncolor包括包括fillcolor和pencolor,即填充颜色和画笔颜色，设置color时会同时设置fillcolor和pencolor为相同的颜色。\nimport turtle as tt.color(&quot;red&quot;) # 将填充颜色和画笔颜色全部设置为红色t.fillcolor(&quot;yellow&quot;) # 将填充颜色设置为黄色t.pencolor(&quot;blue&quot;) # 将画笔颜色设置为蓝色\n\n上述程序则最终会将画笔设置为蓝色，填充颜色设置为黄色，因为前面设置的color被后面再次设置的fillcoloe和pencolor二次覆盖掉了\n\nturtle.write进行写字\nimport turtle as tt.pu()t.goto(200,200)# 不需要t.pd()落笔也可以写字t.write(&quot;新年快乐！&quot;, font=(&quot;楷体&quot;, 36))\n\n填充颜色是否需要落笔\nimport turtle as tt.pu()t.fillcolor(&quot;yellow&quot;)t.begin_fill()t.circle(200)t.end_fill()\n\n通过调试发现不落笔也可以填充颜色，与write写字一样，无需落笔也可实现相应的功能\n\nturtle.done()函数的作用\nimport turtle as tt.circle(200)t.done()\n\n在程序末尾增加turtle.done()，可以让程序在双击运行时画的图案不消失\n\n\n\n课后作业将圆形方孔钱上的四个字补充完整\n"},{"title":"Python 初识urllib模块进行爬虫","url":"/2021/09/27/Python-urllib/","content":"Python 初识urllib模块进行爬虫\n复习回顾\n列表的遍历与取值\n字典的查询\n导包的方式\n\n\n本节新知\nurllib模块的使用\n该模块会模拟我们的浏览器进行访问网页操作并返回网页里面的内容，注意urlopen返回的是一个对象，我们需要通过它的read方法来得到网页的内容，它返回的是一个字符串\nimport urllib.request # 此处导包与之前的导包方式有所不同，若直接导入urllib则request包不会被导入url = &quot;https://www.baidu.com&quot;req = urllib.request.urlopen(url1)html_content = req.read().devode(&quot;utf8&quot;) # 大多网页都为utf-8编码，可尝试不同解码方式进行解码\n\njson数据的处理\n得到字符串后我们需要对该信息进行解析处理，这种json数据外观上接近我们的python里面的字典，我们可以借助json模块来处理该数据，通过其loads函数可以直接将字符串转化为Python中的字典形式，由于Python中字典根据“key”去查值，效率更高，解析数据将会更方便\nimport jsondict_data = json.loads(json_data) # 通过json.loads()可以将字符串转化为Python字典# 通过json.dumps(dict_data)可以将Python字典转化为json数据（即字符串）\n\n嵌套字典与列表的查询\ncity_list = [a,b,c,d]for i in city_list:    print(i)city_dict = &#123;    &quot;Beijing&quot;: &#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3&#125;,    &quot;Shanghai&quot;: &#123;&quot;d&quot;: 4, &quot;e&quot;: 5, &quot;f&quot;: 6&#125;,    &quot;Shenzhen&quot;: &#123;&quot;a&quot;: 2, &quot;c&quot;: 4, &quot;e&quot;: 6&#125;&#125;aaa =  city_dict[&quot;Beijing&quot;][&quot;a&quot;]ddd = city_dict[&quot;Shanghai&quot;][&quot;d&quot;]ccc = city_dict[&quot;Shenzhen&quot;][&quot;c&quot;]\n\n查询字典时可以用中括号进行查值，但是当该键不存在的时候会报错，所以只能在保证该键一定存在的情况下使用，否则需使用get方法进行查值。\n\n\n\n课后作业使用urllib模块 实现检测B站up主更新状况，实时推送up主更新\nTips：通过urllib模块来轮询该up历史动态，并记录返回的动态的列表 中第一条动态对应的时间戳，存储到变量中，当监测到该值发生变化时则进行判断，该值变大则说明up更新了，变小则说明删除了动态\n"},{"title":"Python字典","url":"/2021/09/22/Python%E5%AD%97%E5%85%B8/","content":"Python字典\n复习回顾\n列表[] 可变，可嵌套\n集合{} 无序，可以去重\n元组() 不可变\n\n\n本节新知\n字典的定义字典由一对一对的键-值对组成，即包括索引和数据，Python每次查询字典时根据索引去查询数据，效率会大大提升\n\ndict_a = &#123;&quot;a&quot;: 123&quot;b&quot;: 456&quot;c&quot;: &quot;abc&quot;&#125;\n\n\n字典的常用函数\n\nprint(a.keys()) #打印a的键，即索引。dict_keys([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])print(a.values()) # 打印a的值，即保存的数据。dict_values([123, 456, &#x27;abc&#x27;])print(a.items()) # 打印a的键-值对。dict_items([(&#x27;a&#x27;, 123), (&#x27;b&#x27;, 456), (&#x27;c&#x27;: &#x27;abc&#x27;)])\n\n\n字典的增删改查\n\na[&quot;d&quot;] = 789 # 字典索引不可重复，必须为不存在的索引才会增加a.pop(&quot;c&quot;) # 根据索引删除a.clear() # 清空全部del a[&quot;c&quot;] # 通用a[&quot;a&quot;] = 135 # 当索引已存在时，再次赋值会修改原来的数据print(a[&quot;c&quot;]) # 当该索引存在时，打印它对应的值。不存在时直接报错print(a.get(&quot;c&quot;)) # 当该索引存在时，打印它对应的值。不存在时返回None\n\n\n字符串的格式化输出之二\n\n通过占位符“%s”， “%d”等来进行占位，并在其后用变量进行填充\n\nname = &quot;张三&quot;age = 16high = 1.80print(&quot;我叫%s，我今年%d岁，我身高是%.2f米。&quot;%(name, age, high))\n\n\n通过“{}”进行格式化输出\n\nname = &quot;张三&quot;age = 16high = 1.80print(f&quot;我叫&#123;name&#125;，我今年&#123;age&#125;岁，我身高是&#123;high&#125;米。&quot;) # 字符串前面要加个f\n\n\n\nrange()拓展\nrange(起始，终止，步长)，包括前面，不包括后面\nfor i in range(9,1,-1): # 起始为9，终止为5，包括9.不包括5，逆向生成    print(i)for i in range(1,10,2): # 起始为1，终止为10.不包括10.每次加二，即1，3，5，7...    print(i)\n\n\n课后作业如何对一个列表去重（用set()和list()函数）\na = [1,2,3,6,3,2,4,1]"},{"title":"Python循环控制和格式化输出","url":"/2021/09/11/Python%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/","content":"循环控制与字符串格式化输出\n复习回顾\n为什么要学习Python？Python的特点是什么？Python与其它计算机语言相比的优缺点\n\n有哪些常用的编辑器或者编程环境？\n\n什么是变量？变量有什么用？变量如何赋值？\n\n变量可以存储哪些数据类型？\n\nif条件判断，逻辑运算符，逻辑表达式，elif如何使用？\n\n如何导包？\n\nwhile循环结构，赋值运算符+&#x3D;\n\nbreak、continue控制语句，字符串格式化输出\n\n\n\n本节新知\n用while循环打印1+2+3+…+100&#x3D;？\n\nsum = 0a = 1while a &lt;= 100:    sum += a    a += 1 # 因为此处设置的a的初始值是1，需要先求和再+1print(sum)\n\n\n用控制语句修改以上代码实现前50的和(使用break语句)\n\nsum = 0a = 1while a &lt;= 100:    sum += a    if a == 50:        break # 当执行50次累加后，直接跳出循环执行print语句    a += 1print(sum)\n\n\n用控制语句修改以上代码实现前100个数中除去50的一共99个数的和(使用continue语句)\n\nsum = 0a = 1while a &lt;= 100:    if a == 50:        a += 1        continue # 当执行第50次循环时，跳出当前循环的后面的语句并进行下一次循环    sum += a    a += 1print(sum)\n\n\n字符串的格式化输出\n\n字符串的格式化输出通过将变量的值来插入模板中，从而使同一个模板来输出不一样的内容，即用到”%s“、”%d“等占位符，并将需要替换进去的变量用”%“连接在该模板字符串的后面，若需替换多个占位符则需要提供多个变量并将多个变量按顺序用括号括起来，并用逗号隔开\n\n\n\n符号\n含义\n数据类型\n\n\n\n%d\n可代替整数\nint\n\n\n%f\n可代替浮点数（小数）\nfloat\n\n\n%s\n可代替\nstring\n\n\nname = &quot;张三&quot;age = 18high = 1.68print(&quot;我叫%s,我今年%d岁了，我的身高是%.2f米&quot;%(name, age, high))  # %.2f表示保留两位小数\n\n\n课后作业用while循环和continue计算1-100中奇数的和\n"},{"title":"Python程序打包","url":"/2021/09/07/Python%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/","content":"Pyinstaller和Nuitka\nPyinstaller\n\npyinstaller -F main.py\n\nNuitka\n\n","categories":["Python"],"tags":["Python"]},{"title":"Python等级考试大纲","url":"/2021/09/03/Python%E7%AD%89%E7%BA%A7%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2/","content":"环境准备Python3.5.2\n自带的IDLE\nVisual Studio Code\nJupyterNotebook\n一级要求了解\n\n几种编程环境的认识与使用\n整型、浮点型、字符串型的拼接和处理\nPython程序的三大结构\n如何安装外部模块\n逻辑表达式的使用\n\n熟悉\n\n什么叫保留字，保留字有什么作用和影响\n变量的命名规则\n数据类型如何进行强制转换\n如何导入模块\n\n掌握\n\n输入输出函数的使用，input，print\n何时缩进？如何注释？\n变量如何赋值，掌握赋值运算符的使用\n掌握基本的数学运算问题\n掌握算数运算符、比较运算符、逻辑运算符的使用\n掌握用顺序结构完成完整的程序\nturtle模块的简单使用，并实现前进后退、转弯，提笔、画点、画圆\n\n二级要求了解\n\n了解列表、集合、字符串、元组、字典等数据类型的使用\n认识程序出错时的错误信息，并学会分析如何进行改正\n了解常用内置函数的使用\n\n熟悉\n\n熟练使用几种编程环境\n如何从网络安装并导入外部模块，如何安装本地模块\n读懂Python程序的三大结构顺序、分支、循环的嵌套结构\n\n掌握\n\n列表的增删改查，获取个数、拼接、排序等常用函数。数据类型的转换\n元组的增删改查、排序\n字符串的分割、结合、替换、检索、长度获取\n字符串格式化输出的一种方式\n熟练使用Python程序的三大结构顺序、分支、循环\n\n三级要求了解\n\n常见的编码格式\n了解常见的几种算法，解析、枚举、排序、查找\n自定义函数的定义和调用\n\n熟悉\n\n二进制、十进制、十六进制之间的转换\n熟悉七种常见数据类型的使用\ncsv文件的读写\n常用内置函数的使用\n\n掌握\n\n会用二维、多维列表、字典保存数据\n一维、二维数据的表示和读写\n熟悉常见的几种异常产生的原因\n熟练掌握并运用异常处理\n\n四级要求了解\n\n了解如何查看Python内置模块的源代码\n算法、执行效率与性能优化\n\n熟悉\n\nPython程序中常见操作的算法设计\n递归，递归变递推\n分治算法\n\n掌握\n\n多参多返回值的函数的定义和调用\n函数调用及其传参、返回值、变量作用域\n掌握第三方库的安装和使用\n\n五级要求了解\n\n面向对象编程\n了解文本文件的读写操作\n\n熟悉\n\n字符串转义、格式化输出的三种方式\n列表推导式、生成器推导式、序列解包、切片\n通过文件来保存数据\n常用库的使用。math、turtle、 random、time、PyInstaller、jieba、wordcloud\n\n掌握\n\n如何进行代码优化，提高执行效率\n熟练掌握列表、集合、字符串、元组、字典的常用操作\n通过查看Python常见模块的源代码来分析其实现方式\n\n六级要求了解\n\n自定义模块的编写\n正则表达式\n\n熟悉\n\n常见的文件处理操作、数据格式化\n数据的可视化操作\n\n掌握\n\n面向对象编程\n数据库的使用，SQLite\nGUI编程，tkinter的使用\n\n"},{"title":"Python课程规划","url":"/2021/09/03/Python%E8%AF%BE%E7%A8%8B%E8%A7%84%E5%88%92/","content":"\n每节课的时间分布：\n课前回顾：10min\n新课学习：35min\n实战练习：30min\n课外拓展（仅针对基础较好的）：5min\n本节总结+课后作业：10min\n\n第一阶段（一级）本阶段主要让学生了解什么是代码编程，如何理解和接受这门语言，注重让学生能够独立写出完整的可以正常运行的代码\n导入课通过可视化程序激发学生们的兴趣，通过turtle等模块展示花瓣的绘制、在线音乐的爬取、qq红包一笔画破解等来吸引同学们的兴趣。\n认识Python为什么要学习Python，Python语言的特点，Python与其他编程语言的区别，学会Python能干哪些事。\nPython与Scratch的衔接找不同，回顾Scratch里面的基本积木，通过简单的例子来说明Python与Scratch的共通 的地方。\n环境的安装与基本代码结构展示Python的学习注重逻辑思维的培养，想同学们强调学习的过程要注重细节，初期代码可以不美观，但要注意Python程序的缩进结构。\n学会简单的print、input函数的使用。\n单行注释 #\n多行注释 `&#96;&#96;这是注释&#96;&#96;&#96;\n多行代码 用\\转义回车键\n认识几种简单的数据类型整型 浮点型 字符串 列表 元组 字典 布尔型\n数据类型的强制转换\n变量变量的赋值 &#x3D;，即\n变量名 &#x3D; 变量值\n多个变量同时赋值\n变量可以存储哪些东西？\n整型、浮点型、字符串、布尔型、对象\n变量的命名规则？\n下划线或英文字母开头，不可与关键字重复\n保留字变量名命名不可使用保留字\n运算符算数运算符\n+ - * &#x2F; &#x2F;&#x2F; %\n\n比较运算符\n&gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D;&#x3D; !&#x3D;\n\n赋值运算符\n&#x3D;\n\n逻辑运算符\nand or not\n\n位运算符（了解）\n&gt;&gt; &lt;&lt;\n\n运算符的优先级\n\n\n运算符\n描述\n\n\n\n**\n指数 (最高优先级)\n\n\n~ + -\n按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)\n\n\n* &#x2F; % &#x2F;&#x2F;\n乘，除，取模和取整除\n\n\n+ -\n加法减法\n\n\n&gt;&gt; &lt;&lt;\n右移，左移运算符\n\n\n&amp;\n位 ‘AND’\n\n\n^ |\n位运算符\n\n\n&lt;&#x3D; &lt; &gt; &gt;&#x3D;\n比较运算符\n\n\n&lt;&gt; &#x3D;&#x3D; !&#x3D;\n等于运算符\n\n\n&#x3D; %&#x3D; &#x2F;&#x3D; &#x2F;&#x2F;&#x3D; -&#x3D; +&#x3D; *&#x3D; **&#x3D;\n赋值运算符\n\n\nis     is not\n身份运算符\n\n\nin     not in\n成员运算符\n\n\nnot and or\n逻辑运算符\n\n\nturtle海龟绘图导包import package\n\n第二阶段（二级）本阶段主要强调学生的代码规范，通过第一阶段的学习来逐步了解这门语言，则下一步需要注重学生良好习惯的培养，该阶段要求学生的程序代码工整优雅，符合PEP8标准\n三大结构顺序最基本的结构，Python程序从上到下依次一行一行被解释运行\n分支单分支\nif 条件1:    代码块1\n\n双分支\nif 条件1:    代码块1else:    代码块2\n\n多分支\nif 条件1:    代码块1elif 条件2:    代码块2elif 条件3:    代码块3eles:    代码块4\n\n循环while循环，通常用于死循环，通过while循环向同学们引入Python中循环的概念，初步接触Python中的循环结构。向大家扩展逻辑真假的常见形式以及while 1与while True的区别。\nfor循环，Python程序最常用的循环语句，通过大量练习让学生掌握循环结构的使用。\nwhile循环与for循环的区别：通常while循环用于死循环，或者已知循环次数的循环；for循环通常用于不知道循环次数的循环；实际使用中两者可以任意选择。\n\n循环控制语句\n\n\nbreak 跳出当前一级的循环，进入到该循环体的外部或上一级\n\n\ncontinue 跳出当前一轮的循环，再次进入到循环体进行下一轮\n\n\npass 无其他意义，仅做代码填充使用\n\n\n嵌套循环\n\n有外层进入内层，再由内层进入外层，经常与循环控制语句搭配使用\n二进制十进制与二进制的转换\n拓展：为什么要用二进制\n\n可靠性高（稳定）\n规则简单\n\n列表可变\n[1, 2, 3]\n列表的截取\n列表的增删改查\n拓展：多级列表\n集合无序，不可重复\n元组不可变\n(1, 2, 3)\n字典可变，键值对，键不可以重复，值可以重复，类比查字典\n从Python 3.6开始，字典是变成有顺序的了\n{“a”: 1, “b”: 2, “c”:3}\n字典的增删改查\n拓展：常见的保存数据的方式之json\n&#123;    &quot;a&quot;: 1,    &quot;b&quot;: [&quot;apple&quot;, &quot;pear&quot;, &quot;banana&quot;],\t&quot;c&quot;: &#123;        &quot;a&quot;: 123,        &quot;b&quot;: 456    &#125;&#125;\n\n字符串字符串的截取\n字符串常见的处理函数，切片…\na = &quot; 123 &quot;a.strip()a.lstrip()a.rstrip()\n\n转义 \\\n编码python程序源代码的编码和解释器默认编码不同时则产生乱码现象，可在源代码首行加入注释以指定文件编码类型\n\n源代码以utf-8编码保存，则可标明utf-8或utf8\n\n#coding:utf-8\n\n源代码以ansi编码保存，则可标明ansi或gbk或gb2312\n\n#coding:gbk\n\nutf-8编码，gbk编码\n\n\n\n编码\n范围\n大小\n\n\n\nASCII\n仅英文数字和特殊符号\n1字节\n\n\nANSI\n包含ASCII的扩充，如简体中文则相当于GB2312\n中文2字节\n\n\nGB2312\n包含简体中文\n中文2字节\n\n\nGBK\n包含简体中文、繁体中文等\n中文2字节，英文1字节\n\n\nUnicode\n内存中选用的编码\n定长\n\n\nUTF-8\n所有字符\n中文3字节，英文1字节\n\n\nwindows默认字符集 GBK\nLinux默认字符集 UTF-8\n第三阶段（三级）本阶段着重强调函数的使用，来提高代码的复用率，更加锻炼学生的逻辑思维能力\n函数函数的创建与调用拓展：函数名的命名规则\n传递参数与返回值函数的嵌套global、nonlocal全局变量和局部变量之间的区别\n常见的内置函数的使用获取当前时间\nimport timetime.time()time.datetime()time.ctime()\n\n时间的字符串格式化输出\nimport timetime.strifttime(&quot;%Y-%m-%d %H:%M:%S&quot;, timestamp)\n\n程序的手动终止\nimport osos.exit()\n\n生成随机数\nimport randomrandom.randInt()random.randFloat()\n异常处理常见的几种异常，以及几种异常之间的关系，通过学习本节课来看懂程序出现错误的原因，并学会如何去处理异常。\ntry:    a = 2 / 0except SyntaxError:    print(&quot;语法错误&quot;)except:    print(&quot;其他错误&quot;)else:    print(&quot;太好了，没有错误&quot;)finally:    print(&quot;我一定会出现的&quot;)\n\nraise抛出异常\n拓展：通常哪些地方需要用到异常处理？各种异常之间的关系？哪些异常可以被捕捉？sys.exit()是否可以被捕获？\n\nBaseException\n\n\nException\n\n\nSyntaxError\n\n\nIndexError\n\n\nValueError\n\n\nModuleNotFoundError\n\n算法解析、枚举、排序、查找\n文件操作两种打开文件的方式\n\nopen函数\n\nfile = open(&quot;1.txt&quot;)file.close()\n\nwith open()\n\nwith open(&quot;123.txt&quot;, &quot;w&quot;) as f:    content = f.read()\n\n常见的几种打开文件的方式\n\nr 只读\n\n\nw 写\n\n\na 增加\n\n\nb 以二进制方式打开\n\n拓展：二进制文件与文本文件的区别；操作系统是如何识别文本文件和二进制文件的。\n数据的存储\nxml 整齐、复杂、不易阅读\njson 简洁、直观\nprotobuf 序列化、不易阅读、体积小、方便传输\ncsv 自动化办公\n\n装饰器和语法糖第四阶段（四级+）本阶段注重学生的各方面能力的提升，进一步加深对Python语言的理解，通过阅览Python自带模块的源码，更能让自己写出简洁、优雅的代码，通过拓展一些相关知识，也培养了学生接触新知的能力，多方面的综合也带来更加高的难度与挑战\n面向对象编程简介什么是面向对象编程，面向对象编程与面向过程编程的特点与优缺点\n通过面向对象编程能更好地帮助大家共同完成一个项目，从而加快了团队的效率；但是运行效率不如面向过程编程。\n类与对象的关系拓展：类和对象的命名规则\n继承Python是单继承，一个子类只允许继承一个父类\n重载重载发生在一个类的内部\n封装限制变量以及函数等的权限，来保护类的内部属性结构不被破坏。实际上Python对权限的把控很宽泛，无实际限制。\n多态多态发生在多个类之间\n理解多态和重载的区别\n列表推导式、生成器推导式列表推导式、生成器与循环结构的结合\n序列解包、切片通过本节的学习，可以让自定义函数有更加自由的定义方式，传递可变个数的参数给同一个函数，从而间接实现面向对象的类重载特性\n正则表达式文本匹配与处理\n数据库通过数据库完成数据的增删改查\n\nSQLite\n\n内存分析通过了解内存内部的数据传递的方式能更加有利于对计算机语言的理解，使代码更不容易出错，且代码执行效率更高\n深浅拷贝通过上一章节内存分析的学习，了解深浅拷贝之间的区别。浅拷贝相当于创建了一个快捷方式，深拷贝相当于复制了一个对象\n设计模式简要了解常见的一到两种设计模式\n\n单例模式\n工厂模式\n\n网络协议了解get、post请求，完成简单的爬虫练习,通过发送http请求获得返回的数据，进行处理后通过与文件的读写相结合，进行数据的保存与处理\nTkinterGUI编程\n"},{"title":"Python调用系统通知","url":"/2021/08/21/Python%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5/","content":"Windows10实现from win10toast import ToastNotifiertoast = ToastNotifier()toast.show_toast(title=&quot;This is a title&quot;, msg=&quot;This is a message&quot;, icon_path=None, duration=10, threaded=True)\nLinux实现通过系统自带的命令notify-send发送通知\nnotify-send -a app-name -i icon-path title content\n通过第三方包调用系统通知，如dunst\ndunstify --action=&quot;replyAction,reply&quot; &quot;Message received&quot;\n通过Python调用os模块执行命令\nimport osos.system(command)"},{"title":"简记rsync使用方法","url":"/2021/03/17/Rsync/","content":"简介替代ftp、ssh等工具向服务器上传文件或从服务器下载文件，也可在本机通过rsync替代cp、mv命令。默认情况下，rsync使用”quick check”算法快速检查源文件和目标文件的大小、mtime(修改时间)是否一致，如果不一致则需要传输。\n常用命令[官网使用方法][“https://www.samba.org/ftp/rsync/rsync.html&quot;]\nrsync -a source destination # 递归，同步元信息rsync -anv source/ destination # 模拟结果，n模拟，v输出结果rsync -av --exclude &#x27;*.txt&#x27; source/ destination # 忽略txtrsync -av --exclude=&#123;&#x27;file1.txt&#x27;,&#x27;dir1/*&#x27;&#125; source/ destinationrsync -av --include=&quot;*.txt&quot; --exclude=&#x27;*&#x27; source/ destination\n","categories":["Linux"],"tags":["rsync","文件同步"]},{"title":"Archlinux 包管理更新时出错PGP error","url":"/2024/01/01/arch-pgp-error/","content":"Archlinux 包管理更新时出错PGP errorsudo pacman -S archlinuxcn-keyring resolving dependencies... looking for conflicting packages... Packages (1) archlinuxcn-keyring-20230923-1 Total Download Size:   0.26 MiB Total Installed Size:  0.36 MiB :: Proceed with installation? [Y/n]  :: Retrieving packages... archlinuxcn-keyr...   262.7 KiB   780 KiB/s 00:00 [########################] 100% (1/1) checking keys in keyring                     [########################] 100% (1/1) checking package integrity                   [########################] 100% error: archlinuxcn-keyring: signature from &quot;Jiachen YANG (Arch Linux Packager Signing Key) &lt;farseerfc@archlinux.org&gt;&quot; is marginal trust :: File /var/cache/pacman/pkg/archlinuxcn-keyring-20230923-1-any.pkg.tar.zst is corrupted (invalid or corrupted package (PGP signature)). Do you want to delete it? [Y/n]  error: failed to commit transaction (invalid or corrupted package (PGP signature)) Errors occurred, no packages were upgraded.\n\n这个错误表明archlinuxcn-keyring包的PGP签名受到了信任级别的限制。在Arch Linux系统上，为了确保软件包的完整性和安全性，软件包管理器（例如Pacman）使用PGP签名进行验证。在这种情况下，签名的信任级别被认为是边缘信任（marginal trust）。\n你可以尝试以下几种方法解决这个问题：\n\n方法一：手动提高签名的信任级别。\nsudo pacman-key --lsign-key farseerfc@archlinux.org\n这将提高该密钥的信任级别。然后，再次尝试安装archlinuxcn-keyring。\n\n方法二：忽略签名检查请注意，这只是一种权宜之计，不推荐长期使用，因为它降低了系统的安全性。\nsudo pacman -Syy --noconfirm archlinuxcn-keyring\n此命令中的--noconfirm选项用于自动回答“是”以避免确认提示。请确保你真的信任这个源，因为禁用签名检查可能会导致潜在的安全风险。\n\n方法三：手动导入密钥\ngpg --recv-keys &lt;密钥ID&gt;\n你可以从错误消息中找到密钥ID，这里是 “farseerfc@archlinux.org“。然后再次尝试安装archlinuxcn-keyring。\n请注意，最好的方法是手动提高签名的信任级别。这样做是为了确保你在使用Arch Linux系统时保持高安全性。\n\n\n"},{"title":"EV3相关功能的python实现","url":"/2023/03/19/ev3py/","content":"EV3相关功能的python实现，通过python程序来控制EV3主机进行相关的操作。\n#!/usr/bin/env pybricks-micropythonfrom pybricks.hubs import EV3Brickfrom pybricks.ev3devices import (Motor, TouchSensor, ColorSensor,                                 InfraredSensor, UltrasonicSensor, GyroSensor)from pybricks.parameters import Port, Stop, Direction, Button, Colorfrom pybricks.tools import wait, StopWatch, DataLogfrom pybricks.robotics import DriveBasefrom pybricks.media.ev3dev import SoundFile, ImageFilefrom pybricks.messaging import BluetoothMailboxClient, TextMailbox# Create your objects here.ev3 = EV3Brick()ev3.buttons.pressed() # 返回按下的按键的列表，返回值为Button类型ev3.light.on(Color.RED) # 红绿橙ev3.light.off() # 关闭按键灯# Write your program here.ev3.speaker.beep() # 两个参数，频率，持续ev3.speaker.play_notes([&#x27;C4/4&#x27;, &#x27;C4/4&#x27;, &#x27;G4/4&#x27;, &#x27;G4/4&#x27;], tempo=120)ev3.speaker.play_file(&quot;123.mp3&quot;)ev3.speaker.say(&quot;hello,world&quot;)ev3.speaker.set_volume(60)ev3.screen.clear() # 清屏ev3.screen.draw_text(x, y, text, text_color=Color.BLACK, background_color=None) # 写文字ev3.screen.print(&quot;hello,world&quot;)#ev3.set_font()ev3_img = Image(ImageFile.EV3_ICON)ev3.screen.load_image(ev3_img)ev3.screen.draw_image(10, 10, ev3_img, transparent=Color.RED)ev3.screen.draw_pixel(10, 10, color=Color.BLACK)ev3.screen.draw_line(x1, y1, x2, y2, width=1, color=Color.BLACK)ev3.screen.draw_box(x1, y1, x2, y2, r=0, fill=False, color=Color.BLACK)ev3.screen.draw_circle(x, y, r, fill=False, color=Color.BLACK)ev3.battery.voltage() # 电压ev3.battery.current() # 电流# 马达motor1 = Motor(&quot;A&quot;, positive_direction=Direction.CLOCKWISE, gears=None)motor1.speed() # 获取当前速度motor1.angle() # 获取当前角度motor1.reset_angle(angle)motor1.stop()motor1.brake()motor1.hold()motor1.run(5)motor1.run_time(5, 1000, then=Stop.HOLD, wait=True) # Stop.COAST Stop.BRAKEmotor1.run_angle(5, 60, then=Stop.HOLD, wait=True)motor1.run_target(5, 60, then=Stop.HOLD, wait=True)motor1.run_until_stalled(5, then=Stop.COAST, duty_limit=None)# 按压传感器touch_sensor = TouchSensor(&quot;S1&quot;)touch_sensor.pressed() # 获取当前状态# 颜色传感器color_sensor = ColorSensor(&quot;S2&quot;)color_sensor.color() # 获取检测到的颜色color_sensor.ambient() # 返回光的强度，百分比color_sensor.reflection() # 反射百分比color_sensor.rgb() # 返回红绿蓝的值，百分比# 超声波传感器ultrasonic_sensor = UltrasonicSensor(&quot;S3&quot;)ultrasonic_sensor.distance(silent=False) # 测距ultrasonic_sensor.presence() # 检测是否有其他超声波#陀螺仪gyro_sensor = GyroSensor(&quot;S4&quot;, positive_direction=Direction.CLOCKWISE) # 顺时针方向,COUNTERCLOCKWISE逆时针方向gyro_sensor.speed() # 返回陀螺仪速度gyro_sensor.angle() # 返回陀螺仪角速度gyro_sensor.reset_angle(60)wait(1000) # 等待1000msstop_watch = StopWatch()stop_watch.time() # 获取秒表当前时间stop_watch.pause() # 停止秒表stop_watch.resume() # 继续秒表stop_watch.reset() # 重置秒表# 蓝牙服务端server = BluetoothMailboxServer()mbox = TextMailbox(&#x27;greeting&#x27;, server)print(&#x27;waiting for connection...&#x27;)server.wait_for_connection()print(&#x27;connected!&#x27;)mbox.wait()print(mbox.read())mbox.send(&#x27;hello to you!&#x27;)# 蓝牙客户端SERVER = &#x27;ev3dev&#x27;client = BluetoothMailboxClient()mbox = TextMailbox(&#x27;greeting&#x27;, client)print(&#x27;establishing connection...&#x27;)client.connect(SERVER)print(&#x27;connected!&#x27;)mbox.send(&#x27;hello!&#x27;)mbox.wait()print(mbox.read())\n","tags":["EV3"]},{"title":"chromium继续启用谷歌同步服务","url":"/2021/08/21/chromium%E7%BB%A7%E7%BB%AD%E5%90%AF%E7%94%A8%E8%B0%B7%E6%AD%8C%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1/","content":"终端下输入以下内容\necho &quot;--oauth2-client-id=77185425430.apps.googleusercontent.com--oauth2-client-secret=OTJgUOQcT7lO7GsGZq2G4IlT&quot; &gt;&gt; ~/.config/chromium-flags.conf\n\n[竹林里有冰][https://zhullyb.top/2021/04/15/login-chromium-with-the-api-of-chrome/]\n"},{"title":"文件与文件夹的解压缩","url":"/2024/04/11/files-zip-unzip/","content":"软件常见的解压缩软件对比\n\n\n\n软件名称\n是否有广告\n支持的压缩文件格式\n是否收费\n\n\n\nwindows资源管理器\n无\n仅zip(非加密)\n系统自带\n\n\nWinRAR\n有\n多\n付费\n\n\nBandizip\n有\n多\n付费\n\n\n7z\n无\n多\n免费\n\n\n安装\n下载安装包\n7z软件安装包点击下载地址\n\n安装\n\n\n检测是否安装成功\n\n\n\n安装完成\n\n如果点击左下角开始菜单看不到软件，可继续用键盘输入7看能否看到\n\n\n\n压缩\n将需要压缩的内容移动到同一个文件夹\n\n鼠标右键点击文件夹，并依次选择7-Zip--&gt;添加到xxx.zip\n\n\n\n\n解压缩\n选中需要解压缩的文件，通常为.zip 、.rar格式\n\n点击右键，依次选择7-Zip --&gt; 提取到当前位置\n\n\n\n\n","tags":["windows使用"]},{"title":"fyne入门","url":"/2022/12/29/fyne%E5%85%A5%E9%97%A8/","content":""},{"title":"linux 更改文件属性之 chattr","url":"/2023/11/10/linux%20%E6%9B%B4%E6%94%B9%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E4%B9%8B%20chattr/","content":"给文件（文件夹）添加不可修改属性\nchattr +i file_name # 文件不可修改、不可删除chattr +i dir_name # 文件夹内子文件可修改，但不可增删其他文件\n\n给文件添加仅增添属性\nchattr +i file_name # 文件可追加内容，不可修改、删除内容\n\n给文件（文件夹）删除不可修改属性\nchattr -i file_namechattr -i dir_name\n"},{"title":"ranger 常用快捷键","url":"/2021/11/17/ranger-shortcut-key/","content":"ranger常用快捷键&lt;F7&gt;    mkdircw      重命名yy      复制dd      剪切pp      粘贴dD      删除空格    多选v       反选/全选/       搜索zh      显示隐藏文件du      显示大小o       排序q       退出ctrl+n  多标签shift+s 进入当前目录"},{"title":"Python中函数的调用与变量的作用域","url":"/2021/11/02/python-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/","content":"Python中函数的调用与变量的作用域\n复习回顾\n函数的作用\n函数的定义\n程序的入口\n\n\n本节新知\n函数的返回值\n函数通常都有返回值，通过return关键字来进行返回，若函数无返回值，则返回None。return后的语句都不会被执行，return返回值可以有多个。\ndef my_add(a, b):    sum = a + b    return sum    print(sum)my_add(2, 4)\n\n该程序运行后无任何反应，由于print()函数前有return语句，则print语句不可能被执行。且my_add函数调用后返回了6，但是并没有打印这个值，此时程序中的my_add(2, 4)相当于整数6,但是这个6并没有被打印。\ndef my_add(a, b):    sum = a + b    return a, b, sumfirst, second, third = my_add(2, 4)print(f&quot;第一个数字是&#123;first&#125;,第二个数字是&#123;second&#125;,这两个数的和为&#123;third&#125;&quot;)\n\n函数调用时传递参数可以为多个，且返回值也可以是多个，Python中赋值可以多个变量同时进行赋值\n\n全局变量\n全局变量即为程序中函数外部定义的变量\na = 1b = 2c = 6 # 此处定义的变量a和b和c即为全局变量def my_add(x, y):    print(c) # 函数内部可以读取全局变量的值    c = 100    sum = x + y    print(my_add(a, b))print(c) # 函数内部不可修改全局变量的值\n\n局部变量\n局部变量即为程序中函数内部定义的变量\na = 1b = 2def my_add(x, y):    c = 100 # 此处定义的变量c即为局部变量    sum = x + y    print(my_add(a, b))print(c) # 报错，函数外部不可以读取局部变量的值\n\n拓展\na = 2def func():    # a+=1    print(a)    func()\n\n当程序直接运行时相当于函数内部读取全局变量的值，是可以读取的。但是当a+&#x3D;1的时候，相当于重新定义了一个局部变量a，然后将a的值增加1，但是此时的a已经变成局部变量了，且变量a目前没有被赋值，所以程序报错。\n\n\n\n课后作业复习Python中内置的常见函数\n"},{"title":"yaml_front_matter 示例","url":"/2025/04/16/yaml_front_matter/","content":"sticky: 9999excerpt: 这是《Keep 主题使用指南》的摘要信息......home_cover: /images/home-cover-img.pnghome_cover_height: 120password: xxx"},{"title":"systemd服务","url":"/2021/08/05/systemd/","content":"编写systemd单元文件将单元文件放至&#x2F;etc&#x2F;systemd&#x2F;system文件夹\nnvim /etc/systemd/system/unit\n\n[Unit]Description=service_description[Service]ExecStart=path_to_executable[Install]WantedBy=default.target\n\n将需要执行的脚本赋予可执行权限\nchmod +x path_to_shell\n\n普通用户的单元文件将单元文件放至~&#x2F;.config&#x2F;systemd&#x2F;user文件夹\nnvim ~/.config/systemd/user\n\n启动服务systemctl start daemon.service # 启动服务systemctl status daemon.service # 查看服务状态\n","categories":["Linux"],"tags":["systemd"]},{"title":"创意编程大赛建议","url":"/2021/09/23/%E5%88%9B%E6%84%8F%E7%BC%96%E7%A8%8B%E5%A4%A7%E8%B5%9B/","content":"Python编程设计\n可涉及的第三方库\nNumpy计算\nMatplotlib绘制统计图\nJieba分词\nPillow绘图\nPygameGUI游戏\nEasygui简单的GUI界面\n\n\n可选题目\n通过easygui设计一个计算器\n通过easygui和字符串的内置函数实现记事本的查找功能\n通过re正则模块检测文章中的不文明现象\n通过Jieba模块分析文章中的词频\nurllib抓取疫情数据并结合Easygui实现查询功能\n设计一个简单的后台图书管理系统\n…\n\n\nEasygui使用方法import easygui as egeg.msgbox(msg=&quot;我一定要学会编程！&quot;,title=&quot;标题部分&quot;,ok_button=&quot;加油&quot;)eg.ccbox(&quot;亲爱的还玩吗?&quot;,choices=(&quot;还要玩！&quot;,&quot;算了吧/(ㄒoㄒ)/~~&quot;))eg.buttonbox(msg=&quot;你喜欢下面哪种水果?&quot;,title=&quot;&quot;,choices=(&quot;西瓜&quot;,&quot;苹果&quot;,&quot;草莓&quot;))print(eg.enterbox(msg=&quot;请说出此时你的心里话&quot;,title=&quot;心里悄悄话&quot;))print(eg.passwordbox(msg=&quot;请输入您的密码&quot;))\n\njson模块使用方法import jsondict_data = json.loads(json_data)json_data = json.dumps(dict_data)\n\nre模块使用方法import rerece_list = re.findall(&quot;正则表达式&quot;, &quot;要匹配的内容&quot;)for i in rece_list:    print(i)\n\n\nJieba模块使用方法rece_list = jieba.lcut(&quot;str字符串内容&quot;)for i in rece_list:    print(i)\n\n\nurllib模块使用方法import urllib.requestreq = urllib.request.urlopen(&quot;https://baidu.com/&quot;)html_text = req.read().decode(&quot;utf8&quot;)\n\n\n\n\n\n\n\nScratch图形化编程\n可考虑的方向\nscratch森林冰火人\nscratch疫情防控\nscratch疏水系统\n…\n\n\n"},{"title":"文件传输 & 同步方式全解析：为什么我最终选择了 rsync","url":"/2025/04/22/%E5%A4%9A%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5/","content":"在日常工作或生活中，文件传输与同步是一项基础但常常被低估的重要任务。从几百 KB 的配置文件，到几十 GB 的照片和视频，每个人都需要一套既快速又可靠的解决方案。\n今天这篇文章，我将整理常见的文件传输与同步方式，并重点讲讲为什么我最终选择了 rsync 作为主力工具。\n\n📱 日常常见：微信 &#x2F; QQ 文件传输很多人最熟悉的方式，就是：\n\n在手机微信里「传输助手」发给自己\n用 QQ「我的设备」同步文件\n\n✅ 优点：\n无需额外安装工具\n操作简单，上手门槛低\n支持跨设备传输（手机 → 电脑）\n\n❌ 缺点：\n压缩严重：图片、视频默认会被压缩，丢失质量\n大文件受限：超过 100MB 甚至更小的文件很难传\n断点续传困难：网络中断就得重新来\n非自动化：适合手动传，不适合持续同步或备份\n\n\n📂 网盘类：百度网盘、阿里云盘、OneDrive、iCloud、Google Drive云盘是另一种广泛使用的文件同步方案，适合跨设备或跨平台使用。\n✅ 优点：\n文件在线存储，随时可用\n支持跨设备同步\n某些网盘支持版本历史、协作功能\n\n❌ 缺点：\n上传&#x2F;下载限速（尤其是百度网盘）\n需要登录账号，有平台绑定\n隐私存疑：服务端可见你的文件\n同步延迟不可控：非实时、调度不透明\n\n\n🔗 局域网直传：LocalSend、Snapdrop、AirDrop这些工具适合在局域网中快速传输文件：\n\nLocalSend\nSnapdrop（基于 Web 的 AirDrop 替代）\nApple 的 AirDrop\n\n✅ 优点：\n无需登录，跨平台（尤其是 LocalSend）\n点对点传输，速度快、隐私好\n使用简单，开箱即用\n\n❌ 缺点：\n仅限局域网内使用\n无法自动化或批量同步\n不适合远程传输或长期备份\n\n\n🔁 真·同步工具：SyncthingSyncthing 是一款开源的、点对点的文件同步工具，使用者可以建立多个节点，在不同设备之间实现持续、自动的同步。\n✅ 优点：\n自动同步，实时检测变化\n端对端加密，安全性高\n跨平台，UI 友好，适合新手\n\n❌ 缺点：\n对文件冲突处理不够智能\n大量文件变动时性能偏弱\n对局域网更友好，跨网略显复杂\n\n\n💪 真正专业的文件传输工具：rsync终于来到主角 —— rsync\n这是一款非常经典、稳定、强大的文件同步&#x2F;备份工具，适合在各种环境中精确控制文件的同步行为。\n✅ 优点：\n极高效率：只同步变更内容（支持增量传输）\n稳定可靠：可用于服务器间定时同步&#x2F;备份\n可脚本化：完美融入自动化流程\n跨网络、跨系统支持好\n\n❌ 缺点：\n命令行操作为主，有一定学习成本\n不带 UI（不过有前端工具如 Grsync）\n对新手不够友好，但值得掌握\n\n💡 示例用法：# 将本地文件夹同步到远程服务器rsync -avz ./local/ user@remote:/home/user/backup/# 本地文件夹之间同步（跳过不变的文件）rsync -a --delete ./source/ ./destination/# 带进度条和压缩rsync -avz --progress ./source/ user@remote:/data/\n\n\n🧠 总结：选择方案看你的用途\n\n\n使用场景\n推荐方式\n\n\n\n临时、小文件、跨设备手动传\n微信 &#x2F; QQ &#x2F; LocalSend\n\n\n云端存储、轻同步\n网盘（阿里云盘优于百度）\n\n\n实时局域网同步\nSyncthing\n\n\n自动化、远程备份、大文件传输\n✅ rsync\n\n\n\n✍️ 结语如果你只是偶尔从手机传个图片，那微信就够了。但如果你有大量文件要定期同步、跨设备备份、远程部署 —— 那你真的需要掌握 rsync。\n它不像现代工具那样华丽，却稳得可怕，效率惊人，而且能配合 cron、SSH 等组合出任意你想要的传输策略。\n"},{"title":"纯牛马使用说明","url":"/2025/05/28/%E7%BA%AF%E7%89%9B%E9%A9%AC%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","content":"使用说明一、激活\n查看设备码\n\n\n发送设备码给管理员\n\n\n填入激活码并激活\n\n\n二、导入班级\n打开凤凰系统，找到未开班班级\n\n\n切换到已开班班级，此时获取到已开班级信息\n\n\n复制班级信息\n\n\n导入班级，粘贴刚才复制的内容到上方输入框，选中需要导入的班级，点击导入\n\n\n\n三、导入学生\n清空后，点开任一班级\n\n\n获取学生列表，复制全部内容\n\n\n点击导入学生，粘贴数据，并选择学生导入\n\n\n\n四、TODO\n拖拽更改顺序\n\n\n右键编辑内容，设定时间，删除\n\n\n已完成为灰色，已超时为红色，进行中为蓝色，未开始为黑色\n\n\n\n五、课后反馈\n添加课后反馈到“库”\n\n\n\n使用课后反馈，选择班级，选择课次，复制\n\n\n\n六、常用语\n找到这个文件，并打开（暂时没添加GUI操作界面）\n\n\n手动添加，按照这个格式\n\n\n关闭app，重启生效\n\n\n\n"},{"title":"解决Arch Linux下adb提示unauthorized","url":"/2021/08/21/%E8%A7%A3%E5%86%B3Linux%E4%B8%8Badb%E6%8F%90%E7%A4%BAunauthorized/","content":"安装包android-tools, android-udev\nsudo pacman -S android-tools android-udev"},{"title":"解决ssh一段时间后自动断开","url":"/2021/08/06/%E8%A7%A3%E5%86%B3ssh%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E5%90%8E%E8%87%AA%E5%8A%A8%E6%96%AD%E5%BC%80/","content":"从客户端解决通过客户端向服务端ssh间歇发送心跳\nsudo vim/etc/ssh/ssh_config\n\nServerAliveInterval 30 # 每隔30秒向服务端发送一次心跳ServerAliveCountMax 6 # 当连续6次发送失败时断开连接\n\n从服务端解决通过服务端ssh不断向客户端发送心跳\nsudo vim/etc/ssh/sshd_config\n\nClientAliveInterval 30 # 每隔30秒向客户端发送一次心跳ClientAliveCountMax 6 # 当连续6次发送失败时断开连接\n","categories":["Linux"],"tags":["ssh"]}]